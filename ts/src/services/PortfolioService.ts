import { BehaviorSubject } from 'rxjs';
import { z } from 'zod';
import { schemas } from './schema';

// ---------------------------------------------------------------------------
// SCHEMA INTEGRATION
// ---------------------------------------------------------------------------
// We import the Zod schemas generated by 'openapi-zod-client' from the
// Go backend's OpenAPI specification. This ensures our frontend validation
// rules (types, required fields, enums) stay perfectly in sync with the backend.
export const PortfolioSummarySchema = schemas.Summary;

// ---------------------------------------------------------------------------
// TYPE INFERENCE
// ---------------------------------------------------------------------------
// Instead of manually defining a TypeScript interface, we use `z.infer<>`.
// This guarantees that the TypeScript type `PortfolioSummary` matches the
// structure validated by `PortfolioSummarySchema` at runtime.
// If the backend API changes and we regenerate schema.ts, this type will
// automatically update, flagging any compilation errors immediately.
export type PortfolioSummary = z.infer<typeof PortfolioSummarySchema>;

// Interface for the fetch dependency
export interface IFetcher {
    (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
}

export interface PortfolioConfig {
    apiBaseUrl: string;
    fetcher?: IFetcher;
}

export class PortfolioService {
    private _summary$ = new BehaviorSubject<PortfolioSummary>({
        balance: 0,
        currency: 'USD',
        trend_percent: 0,
        trend_direction: 'neutral'
    });

    public summary$ = this._summary$.asObservable();
    private fetcher: IFetcher = fetch;
    private baseUrl: string = "http://localhost:8000";

    constructor(config: PortfolioConfig = { apiBaseUrl: "http://localhost:8000" }) {
        // Initialize with default values before calling setConfig if needed,
        // or ensure setConfig handles initial undefined states.
        // The setConfig method handles the initial assignment correctly.
        this.setConfig(config);

        // Initial fetch
        this.fetchSummary();
        // Poll every 30 seconds
        setInterval(() => this.fetchSummary(), 30000);
    }

    public setConfig(config: PortfolioConfig) {
        this.fetcher = config.fetcher || this.fetcher || fetch;
        if (config.apiBaseUrl) {
            this.baseUrl = config.apiBaseUrl;
        }
    }

    private async fetchSummary() {
        try {
            // Use configured API URL
            // Ensure no double slash if baseUrl ends with /
            const url = `${this.baseUrl.replace(/\/$/, '')}/portfolio/summary`;

            const response = await this.fetcher(url, {
                headers: {
                    'X-User-ID': 'demo-user'
                }
            });

            if (!response.ok) throw new Error('Failed to fetch summary');

            const data = await response.json();

            // Validate and parse the response using Zod
            // This ensures potential API mismatches are caught early and fields are typed correctly
            const parsedData = PortfolioSummarySchema.parse(data);

            this.updateSummary(parsedData);
        } catch (e) {
            console.error('PortfolioService fetch error:', e);
            // Fallback to simulation/cache if needed?
        }
    }

    public updateSummary(summary: PortfolioSummary) {
        this._summary$.next(summary);
    }

    public getSummary() {
        return this._summary$.getValue();
    }
}

export const portfolioService = new PortfolioService();
